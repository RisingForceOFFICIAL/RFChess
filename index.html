<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RFChess</title>
<style>
:root {
  --bg: #0a0a0a;
  --bg2: #111;
  --bg3: #1a1a1a;
  --accent: #0ea5e9;
  --accent2: #67e8f9;
  --gold: #fbbf24;
  --light-sq: #e8d4b8;
  --dark-sq: #b58863;
  --light-sq-hl: #f6f089;
  --dark-sq-hl: #d4c34d;
  --move-dot: rgba(0,0,0,0.15);
  --capture-ring: rgba(0,0,0,0.15);
  --check-red: #ff6b6b;
  --text: #fff;
  --text2: #888;
}
.light-theme {
  --bg: #f0f0f0;
  --bg2: #e0e0e0;
  --bg3: #d0d0d0;
  --text: #111;
  --text2: #555;
}
/* Board Color Themes */
.board-theme-classic { --light-sq: #e8d4b8; --dark-sq: #b58863; --light-sq-hl: #f6f089; --dark-sq-hl: #d4c34d; }
.board-theme-ocean { --light-sq: #d4e5f7; --dark-sq: #4a90c2; --light-sq-hl: #89d4f0; --dark-sq-hl: #2d7ab8; }
.board-theme-forest { --light-sq: #e0e8d0; --dark-sq: #6b8e4e; --light-sq-hl: #c8f089; --dark-sq-hl: #4a7a2d; }
.board-theme-coral { --light-sq: #f5e6e0; --dark-sq: #c97b63; --light-sq-hl: #f0c889; --dark-sq-hl: #b85a40; }
.board-theme-midnight { --light-sq: #c8c8d0; --dark-sq: #4a4a5e; --light-sq-hl: #a0a0f0; --dark-sq-hl: #3a3a7a; }
.board-theme-neon { --light-sq: #1a1a2e; --dark-sq: #0f0f1a; --light-sq-hl: #0ea5e9; --dark-sq-hl: #0284c7; }
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { overflow-x: hidden; width: 100%; max-width: 100vw; }
body {
  font-family: 'Segoe UI', system-ui, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 16px;
  transition: background 0.3s, color 0.3s;
}
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  max-width: 600px;
  margin-bottom: 20px;
}
.logo {
  font-size: 2rem;
  font-weight: 800;
  letter-spacing: -1px;
}
.logo span { color: var(--accent); }
.controls {
  display: flex;
  gap: 10px;
}
.theme-picker {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 8px;
  background: var(--bg2);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  padding: 12px;
  gap: 8px;
  flex-wrap: wrap;
  width: 180px;
  z-index: 100;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
}
.theme-picker.open { display: flex; }
.theme-option {
  width: 48px;
  height: 48px;
  border-radius: 8px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: all 0.2s;
  overflow: hidden;
}
.theme-option:hover { transform: scale(1.1); border-color: var(--accent); }
.theme-option.active { border-color: var(--accent); box-shadow: 0 0 12px var(--accent); }
.theme-preview {
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
}
.theme-preview span:nth-child(1) { grid-area: 1/1/2/2; }
.theme-preview span:nth-child(2) { grid-area: 1/2/2/3; }
.theme-preview span:nth-child(1)::after { content: ''; display: block; width: 100%; height: 100%; }
.header { position: relative; }
.btn {
  background: var(--bg3);
  border: 1px solid rgba(255,255,255,0.1);
  color: var(--text);
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s;
}
.btn:hover {
  background: var(--accent);
  color: #fff;
  transform: translateY(-2px);
  box-shadow: 0 4px 15px rgba(14, 165, 233, 0.3);
}
.btn-icon {
  padding: 10px 14px;
  font-size: 18px;
}
.game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}
.player-bar {
  display: flex;
  align-items: center;
  gap: 16px;
  width: 100%;
  max-width: 560px;
  padding: 12px 20px;
  background: var(--bg2);
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.05);
}
.player-bar.active {
  border-color: var(--accent);
  box-shadow: 0 0 20px rgba(14, 165, 233, 0.2);
}
.player-avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: var(--bg3);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
}
.player-info { flex: 1; }
.player-name {
  font-weight: 700;
  font-size: 16px;
}
.player-captures {
  display: flex;
  gap: 2px;
  margin-top: 4px;
  min-height: 24px;
  flex-wrap: wrap;
}
.player-captures .cap-piece {
  width: 24px;
  height: 24px;
  display: inline-block;
  vertical-align: middle;
  opacity: 0.9;
}
.player-captures .cap-piece svg {
  width: 100%;
  height: 100%;
}
.player-timer {
  font-size: 24px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  padding: 8px 16px;
  background: var(--bg3);
  border-radius: 8px;
  min-width: 90px;
  text-align: center;
}
.player-timer.low { color: var(--check-red); animation: pulse 1s infinite; }
@keyframes pulse { 50% { opacity: 0.6; } }
.board-wrapper {
  position: relative;
  padding: 12px;
  background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
  border-radius: 16px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
  max-width: calc(100vw - 32px);
}
.board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  --board-size: min(calc(100vw - 56px), 520px);
  width: var(--board-size);
  height: var(--board-size);
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}
.square {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.15s;
}
.square.light { background: var(--light-sq); }
.square.dark { background: var(--dark-sq); }
.square.selected.light { background: var(--light-sq-hl); }
.square.selected.dark { background: var(--dark-sq-hl); }
.square.last-move.light { background: #cdd26a; }
.square.last-move.dark { background: #aaa23a; }
.square.check { background: var(--check-red) !important; }
.square .coord {
  position: absolute;
  font-size: 11px;
  font-weight: 700;
  opacity: 0.6;
  pointer-events: none;
}
.square .coord.file { bottom: 2px; right: 4px; }
.square .coord.rank { top: 2px; left: 4px; }
.square.light .coord { color: var(--dark-sq); }
.square.dark .coord { color: var(--light-sq); }
.piece {
  width: 85%;
  height: 85%;
  cursor: grab;
  user-select: none;
  -webkit-user-select: none;
  filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.4));
  transition: transform 0.1s, filter 0.1s;
  z-index: 2;
  display: flex;
  align-items: center;
  justify-content: center;
}
.piece svg {
  width: 100%;
  height: 100%;
}
.piece:hover { transform: scale(1.08); }
.piece.dragging {
  cursor: grabbing;
  transform: scale(1.15);
  filter: drop-shadow(4px 8px 12px rgba(0,0,0,0.5));
  z-index: 100;
}
.move-hint {
  position: absolute;
  border-radius: 50%;
  pointer-events: none;
  z-index: 1;
}
.move-hint.dot {
  width: 30%;
  height: 30%;
  background: var(--move-dot);
}
.move-hint.capture {
  width: 100%;
  height: 100%;
  border: 5px solid var(--capture-ring);
  border-radius: 50%;
  box-sizing: border-box;
}
.status-bar {
  text-align: center;
  font-size: 18px;
  font-weight: 600;
  color: var(--text2);
  min-height: 28px;
}
.status-bar.check { color: var(--check-red); }
.status-bar.win { color: var(--gold); font-size: 24px; }
/* Modal */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(8px);
}
.modal-overlay.active { display: flex; }
.modal {
  background: var(--bg2);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 20px;
  padding: 40px;
  text-align: center;
  max-width: 400px;
  animation: modalIn 0.3s ease-out;
}
@keyframes modalIn {
  from { transform: scale(0.9); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}
.modal h2 {
  font-size: 28px;
  margin-bottom: 12px;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.modal p { color: var(--text2); margin-bottom: 24px; }
.modal-btns { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
.promo-modal .promo-pieces {
  display: flex;
  gap: 16px;
  justify-content: center;
  margin: 24px 0;
}
.promo-piece {
  width: 80px;
  height: 80px;
  padding: 12px;
  background: var(--bg3);
  border: 2px solid transparent;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.promo-piece svg {
  width: 100%;
  height: 100%;
}
.promo-piece:hover {
  border-color: var(--accent);
  transform: scale(1.1);
  box-shadow: 0 0 20px rgba(14, 165, 233, 0.3);
}
/* Move history */
.history-panel {
  max-width: 560px;
  width: 100%;
  background: var(--bg2);
  border-radius: 12px;
  padding: 16px;
  max-height: 120px;
  overflow-y: auto;
}
.history-title {
  font-size: 12px;
  color: var(--text2);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 8px;
}
.history-moves {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.history-move {
  font-size: 13px;
  padding: 4px 8px;
  background: var(--bg3);
  border-radius: 4px;
  font-family: monospace;
}
.history-move .num { color: var(--text2); margin-right: 4px; }
/* Responsive */
@media (max-width: 600px) {
  body { padding: 10px; }
  .header { flex-direction: column; gap: 10px; width: 100%; }
  .player-bar { padding: 8px 12px; width: 100%; max-width: none; }
  .player-avatar { width: 36px; height: 36px; font-size: 22px; }
  .player-timer { font-size: 18px; padding: 6px 10px; min-width: 70px; }
  .piece { width: 80%; height: 80%; }
  .board-wrapper { padding: 6px; max-width: none; width: calc(100vw - 20px); }
  .board { 
    --board-size: calc(100vw - 32px);
    width: var(--board-size);
    height: var(--board-size);
  }
  .history-panel { width: 100%; max-width: none; }
  .game-container { width: 100%; }
}
</style>
</head>
<body>

<div class="header">
  <div class="logo"><span>RF</span>Chess</div>
  <div class="controls">
    <button class="btn" onclick="newGame()">New Game</button>
    <button class="btn" onclick="undoMove()">Undo</button>
    <button class="btn btn-icon" onclick="toggleBoardTheme()" title="Board Theme">ðŸŽ¨</button>
    <button class="btn btn-icon" onclick="toggleTheme()">ðŸŒ™</button>
  </div>
  <div class="theme-picker" id="theme-picker">
    <div class="theme-option" data-theme="classic" title="Classic"><div class="theme-preview"><span style="background:#e8d4b8"></span><span style="background:#b58863"></span><span style="background:#b58863"></span><span style="background:#e8d4b8"></span></div></div>
    <div class="theme-option" data-theme="ocean" title="Ocean"><div class="theme-preview"><span style="background:#d4e5f7"></span><span style="background:#4a90c2"></span><span style="background:#4a90c2"></span><span style="background:#d4e5f7"></span></div></div>
    <div class="theme-option" data-theme="forest" title="Forest"><div class="theme-preview"><span style="background:#e0e8d0"></span><span style="background:#6b8e4e"></span><span style="background:#6b8e4e"></span><span style="background:#e0e8d0"></span></div></div>
    <div class="theme-option" data-theme="coral" title="Coral"><div class="theme-preview"><span style="background:#f5e6e0"></span><span style="background:#c97b63"></span><span style="background:#c97b63"></span><span style="background:#f5e6e0"></span></div></div>
    <div class="theme-option" data-theme="midnight" title="Midnight"><div class="theme-preview"><span style="background:#c8c8d0"></span><span style="background:#4a4a5e"></span><span style="background:#4a4a5e"></span><span style="background:#c8c8d0"></span></div></div>
    <div class="theme-option" data-theme="neon" title="Neon"><div class="theme-preview"><span style="background:#1a1a2e"></span><span style="background:#0f0f1a"></span><span style="background:#0f0f1a"></span><span style="background:#1a1a2e"></span></div></div>
  </div>
</div>

<div class="game-container">
  <div class="player-bar" id="black-bar">
    <div class="player-avatar">â™š</div>
    <div class="player-info">
      <div class="player-name">Black</div>
      <div class="player-captures" id="black-captures"></div>
    </div>
    <div class="player-timer" id="black-timer">10:00</div>
  </div>

  <div class="board-wrapper">
    <div class="board" id="board"></div>
  </div>

  <div class="player-bar" id="white-bar">
    <div class="player-avatar">â™”</div>
    <div class="player-info">
      <div class="player-name">White</div>
      <div class="player-captures" id="white-captures"></div>
    </div>
    <div class="player-timer" id="white-timer">10:00</div>
  </div>

  <div class="status-bar" id="status">White to move</div>

  <div class="history-panel">
    <div class="history-title">Move History</div>
    <div class="history-moves" id="history"></div>
  </div>
</div>

<!-- Promotion Modal -->
<div class="modal-overlay" id="promo-modal">
  <div class="modal promo-modal">
    <h2>Promote Pawn</h2>
    <p>Choose a piece for promotion</p>
    <div class="promo-pieces" id="promo-pieces"></div>
  </div>
</div>

<!-- Game Over Modal -->
<div class="modal-overlay" id="gameover-modal">
  <div class="modal">
    <h2 id="gameover-title">Checkmate!</h2>
    <p id="gameover-msg">White wins</p>
    <div class="modal-btns">
      <button class="btn" onclick="newGame()">Play Again</button>
    </div>
  </div>
</div>

<script>
// SVG Chess Pieces - consistent across all platforms
const SVG_PIECES = {
  // White pieces (filled white, black stroke)
  K: `<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5" fill="#fff" stroke-linecap="butt"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z"/><path d="M11.5 30c5.5-3 15.5-3 21 0M11.5 33.5c5.5-3 15.5-3 21 0M11.5 37c5.5-3 15.5-3 21 0"/></g></svg>`,
  Q: `<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linejoin="round"><circle cx="6" cy="12" r="2.75"/><circle cx="14" cy="9" r="2.75"/><circle cx="22.5" cy="8" r="2.75"/><circle cx="31" cy="9" r="2.75"/><circle cx="39" cy="12" r="2.75"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-3.5-7-5.5 8-5.5-8L13 25 6 13.5 9 26z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z" stroke-linecap="butt"/><path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0" fill="none"/></g></svg>`,
  R: `<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5" stroke-linecap="butt"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" fill="none" stroke-linejoin="miter"/></g></svg>`,
  B: `<svg viewBox="0 0 45 45"><g fill="none" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#fff" stroke-linecap="butt"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke-linejoin="miter"/></g></svg>`,
  N: `<svg viewBox="0 0 45 45"><g fill="none" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#fff"/><path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3" fill="#fff"/><path d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zM14.933 15.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z" fill="#000"/></g></svg>`,
  P: `<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round"/></svg>`,
  // Black pieces (filled black, white stroke details)
  k: `<svg viewBox="0 0 45 45"><g fill="none" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5" fill="#000" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z" fill="#000"/><path d="M20 8h5" stroke-linejoin="miter"/><path d="M11.5 29.5c5.5-3 15.5-3 21 0M11.5 33.5c5.5-3 15.5-3 21 0M11.5 37c5.5-3 15.5-3 21 0" stroke="#fff"/></g></svg>`,
  q: `<svg viewBox="0 0 45 45"><g fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="6" cy="12" r="2.75"/><circle cx="14" cy="9" r="2.75"/><circle cx="22.5" cy="8" r="2.75"/><circle cx="31" cy="9" r="2.75"/><circle cx="39" cy="12" r="2.75"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-3.5-7-5.5 8-5.5-8-3.5 7-7.5-11.5L9 26z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z" stroke-linecap="butt"/><path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0" fill="none" stroke="#fff"/><circle cx="6" cy="12" r="1" fill="#fff" stroke="none"/><circle cx="14" cy="9" r="1" fill="#fff" stroke="none"/><circle cx="22.5" cy="8" r="1" fill="#fff" stroke="none"/><circle cx="31" cy="9" r="1" fill="#fff" stroke="none"/><circle cx="39" cy="12" r="1" fill="#fff" stroke="none"/></g></svg>`,
  r: `<svg viewBox="0 0 45 45"><g fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12.5 32l1.5-2.5h17l1.5 2.5h-20zM12 36v-4h21v4H12z" stroke-linecap="butt"/><path d="M14 29.5v-13h17v13H14z" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M14 16.5L11 14h23l-3 2.5H14zM11 14V9h4v2h5V9h5v2h5V9h4v5H11z" stroke-linecap="butt"/><path d="M12 35.5h21M13 31.5h19M14 29.5h17M14 16.5h17M11 14h23" fill="none" stroke="#fff" stroke-width="1" stroke-linejoin="miter"/></g></svg>`,
  b: `<svg viewBox="0 0 45 45"><g fill="none" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#000" stroke-linecap="butt"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke="#fff" stroke-linejoin="miter"/></g></svg>`,
  n: `<svg viewBox="0 0 45 45"><g fill="none" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#000"/><path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3" fill="#000"/><path d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0z" fill="#fff" stroke="#fff"/><path d="M14.933 15.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z" fill="#fff" stroke="#fff"/></g></svg>`,
  p: `<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round"/></svg>`
};

// Function to get piece HTML
function getPieceHTML(piece) {
  return SVG_PIECES[piece] || '';
}

const PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };

// Game state
let board = [];
let turn = 'w'; // 'w' or 'b'
let selected = null;
let legalMoves = [];
let lastMove = null;
let history = [];
let moveList = [];
let castling = { K: true, Q: true, k: true, q: true };
let enPassant = null;
let whiteTime = 600, blackTime = 600;
let timerInterval = null;
let gameOver = false;
let pendingPromotion = null;
let captures = { w: [], b: [] };

const $board = document.getElementById('board');
const $status = document.getElementById('status');
const $history = document.getElementById('history');
const $whiteTimer = document.getElementById('white-timer');
const $blackTimer = document.getElementById('black-timer');
const $whiteBar = document.getElementById('white-bar');
const $blackBar = document.getElementById('black-bar');
const $whiteCaps = document.getElementById('white-captures');
const $blackCaps = document.getElementById('black-captures');
const $promoModal = document.getElementById('promo-modal');
const $promopieces = document.getElementById('promo-pieces');
const $gameoverModal = document.getElementById('gameover-modal');
const $gameoverTitle = document.getElementById('gameover-title');
const $gameoverMsg = document.getElementById('gameover-msg');

// Initialize
function initBoard() {
  const setup = [
    'rnbqkbnr',
    'pppppppp',
    '........',
    '........',
    '........',
    '........',
    'PPPPPPPP',
    'RNBQKBNR'
  ];
  board = setup.map(row => row.split(''));
}

function newGame() {
  initBoard();
  turn = 'w';
  selected = null;
  legalMoves = [];
  lastMove = null;
  history = [];
  moveList = [];
  castling = { K: true, Q: true, k: true, q: true };
  enPassant = null;
  whiteTime = 600;
  blackTime = 600;
  gameOver = false;
  captures = { w: [], b: [] };
  clearInterval(timerInterval);
  timerInterval = setInterval(updateTimers, 1000);
  $gameoverModal.classList.remove('active');
  $promoModal.classList.remove('active');
  render();
  updateStatus();
}

function render() {
  $board.innerHTML = '';
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const sq = document.createElement('div');
      const isLight = (r + c) % 2 === 0;
      sq.className = 'square ' + (isLight ? 'light' : 'dark');
      sq.dataset.r = r;
      sq.dataset.c = c;

      // Coordinates
      if (c === 0) {
        const rank = document.createElement('span');
        rank.className = 'coord rank';
        rank.textContent = 8 - r;
        sq.appendChild(rank);
      }
      if (r === 7) {
        const file = document.createElement('span');
        file.className = 'coord file';
        file.textContent = 'abcdefgh'[c];
        sq.appendChild(file);
      }

      // Highlights
      if (selected && selected.r === r && selected.c === c) sq.classList.add('selected');
      if (lastMove && ((lastMove.fr === r && lastMove.fc === c) || (lastMove.tr === r && lastMove.tc === c))) {
        sq.classList.add('last-move');
      }

      // Check highlight
      const piece = board[r][c];
      if (piece === 'K' && isInCheck('w')) sq.classList.add('check');
      if (piece === 'k' && isInCheck('b')) sq.classList.add('check');

      // Piece
      if (piece !== '.') {
        const p = document.createElement('span');
        p.className = 'piece ' + (piece === piece.toUpperCase() ? 'white' : 'black');
        p.innerHTML = getPieceHTML(piece);
        p.draggable = true;
        p.addEventListener('dragstart', e => onDragStart(e, r, c));
        p.addEventListener('dragend', onDragEnd);
        sq.appendChild(p);
      }

      // Move hints
      const move = legalMoves.find(m => m.tr === r && m.tc === c);
      if (move) {
        const hint = document.createElement('div');
        hint.className = 'move-hint ' + (board[r][c] !== '.' || move.enPassant ? 'capture' : 'dot');
        sq.appendChild(hint);
      }

      sq.addEventListener('click', () => onSquareClick(r, c));
      sq.addEventListener('dragover', e => e.preventDefault());
      sq.addEventListener('drop', e => onDrop(e, r, c));
      $board.appendChild(sq);
    }
  }
  updateCaptures();
}

function onSquareClick(r, c) {
  if (gameOver) return;
  const piece = board[r][c];
  const isOwnPiece = piece !== '.' && ((turn === 'w' && piece === piece.toUpperCase()) || (turn === 'b' && piece === piece.toLowerCase()));

  // Check if clicking on a legal move
  const move = legalMoves.find(m => m.tr === r && m.tc === c);
  if (move) {
    makeMove(move);
    return;
  }

  // Select own piece
  if (isOwnPiece) {
    selected = { r, c };
    legalMoves = getLegalMoves(r, c);
    render();
  } else {
    selected = null;
    legalMoves = [];
    render();
  }
}

let dragPiece = null;
function onDragStart(e, r, c) {
  if (gameOver) { e.preventDefault(); return; }
  const piece = board[r][c];
  const isOwn = (turn === 'w' && piece === piece.toUpperCase()) || (turn === 'b' && piece === piece.toLowerCase());
  if (!isOwn) { e.preventDefault(); return; }
  dragPiece = { r, c };
  selected = { r, c };
  legalMoves = getLegalMoves(r, c);
  e.target.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  setTimeout(render, 0);
}
function onDragEnd(e) {
  e.target.classList.remove('dragging');
  dragPiece = null;
}
function onDrop(e, r, c) {
  e.preventDefault();
  if (!dragPiece) return;
  const move = legalMoves.find(m => m.tr === r && m.tc === c);
  if (move) makeMove(move);
  else { selected = null; legalMoves = []; render(); }
}

function makeMove(move) {
  const { fr, fc, tr, tc } = move;
  const piece = board[fr][fc];
  const captured = board[tr][tc];

  // Save for undo
  history.push({
    board: board.map(r => [...r]),
    turn, castling: { ...castling }, enPassant, captures: { w: [...captures.w], b: [...captures.b] }, lastMove
  });

  // Capture
  if (captured !== '.') {
    captures[turn].push(captured.toLowerCase());
  }
  if (move.enPassant) {
    const epR = turn === 'w' ? tr + 1 : tr - 1;
    captures[turn].push('p');
    board[epR][tc] = '.';
  }

  // Move piece
  board[tr][tc] = piece;
  board[fr][fc] = '.';

  // Castling
  if (move.castle === 'K') { board[7][5] = 'R'; board[7][7] = '.'; }
  if (move.castle === 'Q') { board[7][3] = 'R'; board[7][0] = '.'; }
  if (move.castle === 'k') { board[0][5] = 'r'; board[0][7] = '.'; }
  if (move.castle === 'q') { board[0][3] = 'r'; board[0][0] = '.'; }

  // Update castling rights
  if (piece === 'K') { castling.K = false; castling.Q = false; }
  if (piece === 'k') { castling.k = false; castling.q = false; }
  if (piece === 'R' && fr === 7 && fc === 0) castling.Q = false;
  if (piece === 'R' && fr === 7 && fc === 7) castling.K = false;
  if (piece === 'r' && fr === 0 && fc === 0) castling.q = false;
  if (piece === 'r' && fr === 0 && fc === 7) castling.k = false;

  // En passant
  if (piece.toLowerCase() === 'p' && Math.abs(fr - tr) === 2) {
    enPassant = { r: (fr + tr) / 2, c: fc };
  } else {
    enPassant = null;
  }

  // Promotion
  if (piece === 'P' && tr === 0) {
    pendingPromotion = { r: tr, c: tc, color: 'w' };
    showPromotion('w');
    lastMove = { fr, fc, tr, tc };
    selected = null; legalMoves = [];
    render();
    return;
  }
  if (piece === 'p' && tr === 7) {
    pendingPromotion = { r: tr, c: tc, color: 'b' };
    showPromotion('b');
    lastMove = { fr, fc, tr, tc };
    selected = null; legalMoves = [];
    render();
    return;
  }

  // Record move
  recordMove(piece, fr, fc, tr, tc, captured !== '.' || move.enPassant, move.castle);

  lastMove = { fr, fc, tr, tc };
  turn = turn === 'w' ? 'b' : 'w';
  selected = null;
  legalMoves = [];
  render();
  updateStatus();
}

function showPromotion(color) {
  $promoModal.classList.add('active');
  const pieces = color === 'w' ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
  $promopieces.innerHTML = '';
  pieces.forEach(p => {
    const btn = document.createElement('div');
    btn.className = 'promo-piece';
    btn.innerHTML = getPieceHTML(p);
    btn.onclick = () => promote(p);
    $promopieces.appendChild(btn);
  });
}

function promote(piece) {
  if (!pendingPromotion) return;
  board[pendingPromotion.r][pendingPromotion.c] = piece;
  $promoModal.classList.remove('active');
  
  // Record the promotion move
  const lastH = history[history.length - 1];
  const pawn = pendingPromotion.color === 'w' ? 'P' : 'p';
  recordMove(pawn, lastMove.fr, lastMove.fc, lastMove.tr, lastMove.tc, false, null, piece);
  
  pendingPromotion = null;
  turn = turn === 'w' ? 'b' : 'w';
  render();
  updateStatus();
}

function recordMove(piece, fr, fc, tr, tc, isCapture, castle, promo) {
  const files = 'abcdefgh';
  const ranks = '87654321';
  let notation = '';
  
  if (castle === 'K' || castle === 'k') notation = 'O-O';
  else if (castle === 'Q' || castle === 'q') notation = 'O-O-O';
  else {
    if (piece.toLowerCase() !== 'p') notation += piece.toUpperCase();
    else if (isCapture) notation += files[fc];
    if (isCapture) notation += 'x';
    notation += files[tc] + ranks[tr];
    if (promo) notation += '=' + promo.toUpperCase();
  }
  
  const enemy = turn === 'w' ? 'b' : 'w';
  if (isCheckmate(enemy)) notation += '#';
  else if (isInCheck(enemy)) notation += '+';
  
  if (turn === 'w') {
    moveList.push({ num: Math.floor(moveList.length / 2) + 1, w: notation, b: '' });
  } else {
    if (moveList.length) moveList[moveList.length - 1].b = notation;
  }
  updateHistory();
}

function updateHistory() {
  $history.innerHTML = moveList.map(m => 
    `<span class="history-move"><span class="num">${m.num}.</span>${m.w} ${m.b}</span>`
  ).join('');
  $history.scrollTop = $history.scrollHeight;
}

function undoMove() {
  if (!history.length || gameOver) return;
  const prev = history.pop();
  board = prev.board;
  turn = prev.turn;
  castling = prev.castling;
  enPassant = prev.enPassant;
  captures = prev.captures;
  lastMove = prev.lastMove;
  selected = null;
  legalMoves = [];
  if (turn === 'b' && moveList.length) {
    moveList[moveList.length - 1].b = '';
    if (!moveList[moveList.length - 1].w) moveList.pop();
  } else if (moveList.length) {
    moveList.pop();
  }
  updateHistory();
  render();
  updateStatus();
}

function getLegalMoves(r, c) {
  const piece = board[r][c];
  if (piece === '.') return [];
  const color = piece === piece.toUpperCase() ? 'w' : 'b';
  const moves = getPseudoMoves(r, c, piece, color);
  // Filter out moves that leave king in check
  return moves.filter(m => {
    const savedBoard = board.map(row => [...row]);
    board[m.tr][m.tc] = board[r][c];
    board[r][c] = '.';
    if (m.enPassant) board[m.enPassant.r][m.enPassant.c] = '.';
    const inCheck = isInCheck(color);
    board = savedBoard;
    return !inCheck;
  });
}

function getPseudoMoves(r, c, piece, color, forAttackCheck = false) {
  const moves = [];
  const type = piece.toLowerCase();
  const dir = color === 'w' ? -1 : 1;
  const enemy = color === 'w' ? 'b' : 'w';

  const addMove = (tr, tc, extra = {}) => {
    if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
      const target = board[tr][tc];
      const targetColor = target === '.' ? null : (target === target.toUpperCase() ? 'w' : 'b');
      if (targetColor !== color) {
        moves.push({ fr: r, fc: c, tr, tc, ...extra });
      }
    }
  };

  const addSlide = (dr, dc) => {
    for (let i = 1; i < 8; i++) {
      const tr = r + dr * i, tc = c + dc * i;
      if (tr < 0 || tr >= 8 || tc < 0 || tc >= 8) break;
      const target = board[tr][tc];
      if (target === '.') moves.push({ fr: r, fc: c, tr, tc });
      else {
        const targetColor = target === target.toUpperCase() ? 'w' : 'b';
        if (targetColor !== color) moves.push({ fr: r, fc: c, tr, tc });
        break;
      }
    }
  };

  if (type === 'p') {
    const startRow = color === 'w' ? 6 : 1;
    // Forward
    if (board[r + dir]?.[c] === '.') {
      addMove(r + dir, c);
      if (r === startRow && board[r + dir * 2]?.[c] === '.') addMove(r + dir * 2, c);
    }
    // Captures
    [-1, 1].forEach(dc => {
      const tr = r + dir, tc = c + dc;
      if (tc >= 0 && tc < 8 && tr >= 0 && tr < 8) {
        const target = board[tr][tc];
        if (target !== '.' && (target === target.toUpperCase() ? 'w' : 'b') === enemy) {
          addMove(tr, tc);
        }
        // En passant
        if (enPassant && enPassant.r === tr && enPassant.c === tc) {
          const epCaptureR = color === 'w' ? tr + 1 : tr - 1;
          moves.push({ fr: r, fc: c, tr, tc, enPassant: { r: epCaptureR, c: tc } });
        }
      }
    });
  }

  if (type === 'n') {
    [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr,dc]) => addMove(r+dr, c+dc));
  }

  if (type === 'b' || type === 'q') {
    [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr,dc]) => addSlide(dr, dc));
  }

  if (type === 'r' || type === 'q') {
    [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr,dc]) => addSlide(dr, dc));
  }

  if (type === 'k') {
    [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dr,dc]) => addMove(r+dr, c+dc));
    // Castling - skip when checking attacks (can't capture via castling, and causes infinite recursion)
    if (!forAttackCheck) {
      if (color === 'w' && r === 7 && c === 4 && !isInCheck('w')) {
        if (castling.K && board[7][5] === '.' && board[7][6] === '.' && !isAttacked(7, 5, 'b') && !isAttacked(7, 6, 'b')) {
          moves.push({ fr: 7, fc: 4, tr: 7, tc: 6, castle: 'K' });
        }
        if (castling.Q && board[7][3] === '.' && board[7][2] === '.' && board[7][1] === '.' && !isAttacked(7, 3, 'b') && !isAttacked(7, 2, 'b')) {
          moves.push({ fr: 7, fc: 4, tr: 7, tc: 2, castle: 'Q' });
        }
      }
      if (color === 'b' && r === 0 && c === 4 && !isInCheck('b')) {
        if (castling.k && board[0][5] === '.' && board[0][6] === '.' && !isAttacked(0, 5, 'w') && !isAttacked(0, 6, 'w')) {
          moves.push({ fr: 0, fc: 4, tr: 0, tc: 6, castle: 'k' });
        }
        if (castling.q && board[0][3] === '.' && board[0][2] === '.' && board[0][1] === '.' && !isAttacked(0, 3, 'w') && !isAttacked(0, 2, 'w')) {
          moves.push({ fr: 0, fc: 4, tr: 0, tc: 2, castle: 'q' });
        }
      }
    }
  }

  return moves;
}

function isAttacked(r, c, byColor) {
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const p = board[row][col];
      if (p === '.') continue;
      const pColor = p === p.toUpperCase() ? 'w' : 'b';
      if (pColor !== byColor) continue;
      const moves = getPseudoMoves(row, col, p, pColor, true);
      if (moves.some(m => m.tr === r && m.tc === c)) return true;
    }
  }
  return false;
}

function findKing(color) {
  const k = color === 'w' ? 'K' : 'k';
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      if (board[r][c] === k) return { r, c };
    }
  }
  return null;
}

function isInCheck(color) {
  const king = findKing(color);
  if (!king) return false;
  return isAttacked(king.r, king.c, color === 'w' ? 'b' : 'w');
}

function hasLegalMoves(color) {
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (p === '.') continue;
      const pColor = p === p.toUpperCase() ? 'w' : 'b';
      if (pColor !== color) continue;
      if (getLegalMoves(r, c).length > 0) return true;
    }
  }
  return false;
}

function isCheckmate(color) {
  return isInCheck(color) && !hasLegalMoves(color);
}

function isStalemate(color) {
  return !isInCheck(color) && !hasLegalMoves(color);
}

function updateStatus() {
  $whiteBar.classList.toggle('active', turn === 'w');
  $blackBar.classList.toggle('active', turn === 'b');
  
  if (isCheckmate(turn)) {
    const winner = turn === 'w' ? 'Black' : 'White';
    $status.textContent = 'Checkmate! ' + winner + ' wins!';
    $status.className = 'status-bar win';
    endGame('Checkmate!', winner + ' wins by checkmate');
  } else if (isStalemate(turn)) {
    $status.textContent = 'Stalemate! Draw.';
    $status.className = 'status-bar';
    endGame('Stalemate!', 'The game is a draw');
  } else if (isInCheck(turn)) {
    $status.textContent = (turn === 'w' ? 'White' : 'Black') + ' is in check!';
    $status.className = 'status-bar check';
  } else {
    $status.textContent = (turn === 'w' ? 'White' : 'Black') + ' to move';
    $status.className = 'status-bar';
  }
}

function endGame(title, msg) {
  gameOver = true;
  clearInterval(timerInterval);
  $gameoverTitle.textContent = title;
  $gameoverMsg.textContent = msg;
  $gameoverModal.classList.add('active');
}

function updateCaptures() {
  const order = ['q', 'r', 'b', 'n', 'p'];
  const sort = arr => [...arr].sort((a, b) => order.indexOf(a) - order.indexOf(b));
  
  $whiteCaps.innerHTML = sort(captures.w).map(p => `<span class="cap-piece">${getPieceHTML(p)}</span>`).join('');
  $blackCaps.innerHTML = sort(captures.b).map(p => `<span class="cap-piece">${getPieceHTML(p.toUpperCase())}</span>`).join('');
}

function updateTimers() {
  if (gameOver || pendingPromotion) return;
  if (turn === 'w') whiteTime--;
  else blackTime--;
  
  const formatTime = s => {
    const m = Math.floor(s / 60);
    const sec = s % 60;
    return m + ':' + (sec < 10 ? '0' : '') + sec;
  };
  
  $whiteTimer.textContent = formatTime(Math.max(0, whiteTime));
  $blackTimer.textContent = formatTime(Math.max(0, blackTime));
  
  $whiteTimer.classList.toggle('low', whiteTime <= 30);
  $blackTimer.classList.toggle('low', blackTime <= 30);
  
  if (whiteTime <= 0) {
    endGame('Time Out!', 'Black wins on time');
  } else if (blackTime <= 0) {
    endGame('Time Out!', 'White wins on time');
  }
}

function toggleTheme() {
  document.body.classList.toggle('light-theme');
  const btns = document.querySelectorAll('.btn-icon');
  const themeBtn = btns[btns.length - 1]; // Last btn-icon is the light/dark toggle
  themeBtn.textContent = document.body.classList.contains('light-theme') ? 'â˜€ï¸' : 'ðŸŒ™';
}

// Board theme picker
var currentBoardTheme = localStorage.getItem('rfchess-board-theme') || 'classic';

function toggleBoardTheme() {
  document.getElementById('theme-picker').classList.toggle('open');
}

function setBoardTheme(theme) {
  // Remove all board theme classes
  document.body.classList.remove('board-theme-classic', 'board-theme-ocean', 'board-theme-forest', 'board-theme-coral', 'board-theme-midnight', 'board-theme-neon');
  document.body.classList.add('board-theme-' + theme);
  currentBoardTheme = theme;
  localStorage.setItem('rfchess-board-theme', theme);
  // Update active state
  document.querySelectorAll('.theme-option').forEach(opt => {
    opt.classList.toggle('active', opt.dataset.theme === theme);
  });
  document.getElementById('theme-picker').classList.remove('open');
}

// Initialize theme picker
document.querySelectorAll('.theme-option').forEach(opt => {
  opt.addEventListener('click', () => setBoardTheme(opt.dataset.theme));
});

// Load saved theme
document.body.classList.add('board-theme-' + currentBoardTheme);
document.querySelectorAll('.theme-option').forEach(opt => {
  opt.classList.toggle('active', opt.dataset.theme === currentBoardTheme);
});

// Close picker when clicking outside
document.addEventListener('click', (e) => {
  if (!e.target.closest('.theme-picker') && !e.target.closest('[onclick*="toggleBoardTheme"]')) {
    document.getElementById('theme-picker').classList.remove('open');
  }
});

// Start
newGame();
</script>
</body>
</html>
